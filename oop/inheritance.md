# Наследование
> Принцип ООП, где мы можем унаследовать, преопределять и использовать все атрибуты и методы родительского класса

```py
class A:
    def method(self):
        print('Метод в классе А')

obj_a = A()
obj_a.method() # Метод в классе А

class B(A): #все что было в классе А, копируется в класс В
    pass

obj_b = B()
obj_b.method() # Метод в классе А
```

> класс А - родительский
> класс В - дочерний

## Преопределение 
> Когда мы создаем метод или атрибут с таким же названием, как и в родительских классах
```py
class C(A):
    def method(self):
        print('Метод в классе C') 

obj_c = C()
obj_c.method()  # Метод в классе C - потому что мы перезаписали метод в классе С, который взяли из класса А
```
## Виды наследование
* одиночное- когда один родительский класс (родитель)
* множественное - когда несколько родительских классов
### Еще допольнильные:
* многоуровневые - когда у родителя есть родитель
* иерархическое - когда у каждого класса есть только один родитель, но у родителя может быть много детей, и ирарахия среди детей (но по факту и среди родителей, но которые не являются главным родителем)
* гибридное - совмещение разных видов наследования 

## Проблемы множественного наследования
1. Проблема ромба (решенная с помощью MRO (с версией 2.3))
> MRO (method resolution order) - встроенный метод в Питон, который простраивает порядок для поиска аттрибутов

```py
class A:
    pass
class B:
    pass
class C(A,B):
    pass

#до MRO 
[С, A, object, C, B, object]

# после MRO
[C, A, B, object]
```
2. Проблема перекрестного наследования (нерешенная, возникает когда невозможно простроить приоритет родителей)

```py
class A:
    pass
class B:
    pass
class C(A,B):
    pass
class D(B,A):
    pass
class E(C,D): # он не понимает, что брать в первую очередь, сначала А, а затем В (из класса С) или нужно сначала В, а затем А (из класса D) --> возникает ошибка
    pass
#TypeError: Cannot create a consistent method resolution
# order (MRO) for bases A, B
```