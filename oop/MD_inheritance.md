# Принципы ООП. Наследование.

## Задание 1

Создайте класс Class1 с 2 методами - first и second.

Создайте второй класс Class2, который наследуется от Class1, и определите в новом классе Class2 ещё 2 метода - third и fourth.

Создайте экземпляр obj от класса Class2 и вызовите у него все четыре метода.

    внутри методов прописывать и возвращать ничего не нужно, можно просто оставить ключевое слово pass. pass говорит Python что функция пока ничего не выполняет, но в будущем возможно вы вернетесь и допишите туда код.
```py
class Class1:
    def first(self):
        pass
    def second(self):
        pass
class Class2(Class1):
    def third(self):
        pass
    def fourth(self):
        pass

obj = Class2()
print(obj.first()) 
print(obj.second()) 
print(obj.third()) 
print(obj.fourth()) 
```
> Чтобы obj нашел методы 1 и 2, то не нужо просто сослаться на родителя класса до этого как в строке 18. Теперь если во время print(obj.first()) 
print(obj.second()), наш код если не нашел данные методы в классе Class2(), то он идет в его род. класс

## Задание 2

Создайте класс A и определите в нём метод method1, который будет печатать строку

Основной функционал

Затем создайте второй класс B, который наследуется от класса A.

Внутри класса B переопределите method1 таким образом, чтобы он помимо строки "Основной функционал", также печатал строку

Дополнительный функционал

Объявите экземпляр класса B в переменной obj и вызовите метод method1. Результат в терминале должен быть:

Основной функционал 
Дополнительный функционал 

```py
class A:
    def method1(self):
        print('Основной функционал')
class B(A):
    def method1(self):
        super().method1()
        print('Дополнительный функционал')

obj = B()
obj.method1()
```
> Возможно добавление род. метода в дочерний метод, сохраняя оба метода