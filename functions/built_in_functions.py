"=========================Встроенные функции========================="
#enumerate - функция, которая принимает последовательность и возвращает генератор, где элеиенты генератора

#enumerate (название переменной для перебора, с какого начать отсчет)- функция, которая позволяет перебирать коллекцию элементов, отслеживая индекс текущего элемента.

#Значение: для создания словарей, при перебора в цикле for мы как раз можем перебирать сразу два элемента одновременно

string = 'hello'
enum = enumerate(string)
print(enum) #<enumerate object at 0x7f1782c51100>
print(list(enum))  #[(0, 'h'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o')]

string = 'world'
enum = enumerate(string, 5) #после название переменной, можно написать с какого числа надо нумеровать 
print(list(enum))  #[(5, 'w'), (6, 'o'), (7, 'r'), (8, 'l'), (9, 'd')]

#дан списко с числами, умножьте на 2 все числа под нечетными индексами, умножьте на 3 все числа с индексом, кратном 3
list1 = [1,4,78,3,7,0,4,2,7]

for ind in range(len(list1)):
    element = list1[ind]
    if ind % 2:   #это тоэе самое как ind % 2 != 0
        list1[ind] = element * 2
    if ind % 3 == 0:  #not ind % 3
        list1[ind] = element * 3
print(list1)

list1 = [1,4,78,3,7,0,4,2,7]
for ind , element in enumerate(list1):
    if ind % 2:   
        list1[ind] = element * 2
    if ind % 3 == 0:  
        list1[ind] = element * 3
print(list1)
#[3, 8, 78, 9, 7, 0, 12, 4, 7]

#создайте словарь, где ключом будет порядковый номер буквы в алфавите, а значением буква

#1 способ
string = 'abc'
list1 = []
list2 = []
for  k,v in enumerate(string, 1):
    list1.append(k)
    list2.append(v)
dict_ = dict(zip(list1,list2))
print(dict_)

#2 способ, он лучше
string = 'abc'
dict_ = {}
for  k,v in enumerate(string, 1):
    dict_[k] = v
print(dict_)

#3 способ, он самый лучший
string = 'abc'
print(dict(enumerate(string,1)))




#zip - функция, которая обьединяет элементы из нескольких последовательностей по индексам в tuple, т.е все элементы под индексом 0 в первый tuple, все элементы под индексом 1 во второй tuple и т.д

list1 = [[1], [2], [3], [4], [5]] # 5
list2 = ["a", "b", "c", "d"] # 4
list3 = [1.0, 2.0, 3.0] # 3
res = list(  zip(list1, list2, list3)  )
#[([1], 'a', 1.0), ([2], 'b', 2.0), ([3], 'c', 3.0)]

#zip - минимум 2 элемента, максимума нет
list1 = [1,2,3,4,5]
list2 = 'abcdefg'
list3 = [0.5, 0.6,0.3]
print(list(zip(list1, list2, list3)))

#[(1, 'a', 0.5), (2, 'b', 0.6), (3, 'c', 0.3)] - самая короткая последовательность в 3 списке, пожтому и вышло только 3 кортежа

"=====================Функция высшего порядка====================="
# это функция, которая:
# 1. принимает в аргументы другую функцию
# 2. возвращает функцию
# 3. создает внутри себя функцию (вложенную функцию)
# 4. вызывает внутри функцию (вложенную функцию)

#Функция map - принимает в аргументы функцию и итерируемый объект. возвращает генератор, в котором все элементы - это результат принимаемой функции, в которую передали элементы последовательности

mapped = map(int, ['1', '2', '3'])
print(mapped) #<map object at 0x7efdd937bf40> - это название обекта в программе с map?
print(list(mapped))  #[1, 2, 3]

#задача
list1 = [1,2,3,4]
#res = [2,3,4,5] - каждый элемент увеличивается на 1

#1 способ
list1 = [1,2,3,4]
def res1(i):   #благодаря map i - это элементы из списка list1
    i = i + 1   #наша функция map он каждый элемент из списка перебирает и соершает это действие 
    return i
print(list(map(res1,list1)))

#2 способ
print(list(map(lambda i: i + 1,list1)))


#filter - принимает в аргументы функцию и итерируемый объект. возвращает генератор, в котором элементы из последовательности прошедшие фильтр (функция вернула True)

list1 = [-2,3,5,-13,4]

#плохой пример;
# def is_positive(i):
#     if i > 0:
#         return True
#     else:
#         return False
    
#плохой пример;
def is_positive(i):
    return i > 0  #(True, False)    #если i будет меньше 0, то он сам по себе не вернется, так как выходит False

list4 = [-2,3,5,-13,4]
print(list(filter(is_positive, list4)))   #[3, 5, 4]
print(list(filter(lambda i: i > 0, list4)))  #[3, 5, 4]

#дан список со строками, оставьте только те строки, которые начинаются с большой буквы

#1 способ
list5 = ['Hello', 'wORLD', 'MAKERS']
def p(i):
    return i[0].isupper()
print(list(filter(p, list5)))

#2 способ
print(list(filter(lambda i: i[0].isupper(), list5)))





# reduce - функция, которую надо импортировать из библеотеки functools (from functools import reduce), она принимает 2 аргумента:

# функция reduce берет из последовательности 2 элемента, отправляет их в функцию. результат и следующий элемент из последовательности снова отправляет в функцию и т.д

#тоже принимает функцию и итерируемый объект. возвращает 1 результат
# - он всегда принимает два элемента (параметра)
from functools import reduce

list1 = [2,4,6,3]

def mul(x,y):
    return x * y
res = reduce(mul,list1)
print(res) 
#144 = 2*4*6*3

string = 'hello'
print(reduce(lambda x,y: x+'$'+y, string))
# h$e$l$l$o
# x='h', y='e' -> 'h$e'
# x='h$e', y='l' -> 'h$e$l'
# x='h$e$l', y='l' -> 'h$e$l$l'
# x='h$e$l$l', y='o' -> 'h$e$l$l$o'

list8 = ['hello', 'world', 'makers', 'bootcamp']
def r(x,y):
    if len(x) > len(y):
        return x
    else:
        return y
print(reduce(r,list8))





